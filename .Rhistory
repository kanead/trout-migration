#'  other (which is a very important property, because, for example,
#'  random processes in parallel simulations should not be influenced
#'  by each other).
#'
#'  Therefore, it makes sence to put the initialization, the simulation,
#'  and the quiting process into separate functions. These functions can
#'  look like the following (if you want to test these, don't forget to
#'  adapt the paths appropriate):
library(rJava)
library(RNetLogo)
#setwd("C:\\Program Files\\NetLogo 6.0.4\\app") #path where netlogo.jar file is stored - ymmv
# load the parallel package
library(parallel)
# detect the number of cores available
processors <- detectCores()
processors
# create a cluster
cl <- makeCluster(processors)
cl
### When using parallelization, everything has to be done for every processor separately.
# Therefore, make functions:
# the initialization function
prepro <- function(dummy, gui, nl.path, model.path) {
library(RNetLogo)
NLStart(nl.path, gui=gui,nl.jarname = "netlogo-6.0.4.jar")
NLLoadModel(model.path)
}
simfun <- function(density) {
sim <- function(density) {
NLCommand("set density ", density, "setup")
NLDoCommandWhile("any? turtles", "go");
ret <- NLReport("(burned-trees / initial-trees) * 100")
return(ret)
}
lapply(density, function(x) replicate(20, sim(x)))
}
# the quit function
postpro <- function(x) {
NLQuit()
}
### Start Cluster
#run the initialization function in each processor, which will open as many NetLogo windows as we have processors
# set variables for the start up process
# adapt path appropriate (or set an environment variable NETLOGO_PATH)
gui <- TRUE
nl.path <- "C:\\Program Files\\NetLogo 6.0.4\\app"
model.path <- "models\\Sample Models\\Earth Science\\Fire.nlogo"
# load NetLogo in each processor/core
invisible(parLapply(cl,
1:processors,
prepro,
gui=gui,
nl.path=nl.path,
model.path=model.path)
)
NLQuit()
NLQuit()
NLQuit()
NLCommand("set anad-death-multiplierF 24)
NLCommand("set female-mate-radius 3")
NLCommand("set carrying-capacity 200")
NLCommand("set prop-parasites 200")
NLCommand("set parasite-load 3")
NLCommand("set conflict? FALSE")
NLCommand("set sneaker? FALSE")
#' run it for 1000 ticks
NLDoCommand(1000, "go")
#' set up a reporter to collect data on the genotype of both sexes
vars <- c("ticks", "who", "g" ,"sex", "anadromous")
agents <- "turtles"
reporters <- sprintf("map [x -> [%s] of x ] sort %s", vars, agents)
nlogo_ret <- RNetLogo::NLReport(reporters)
df1 <- data.frame(nlogo_ret, stringsAsFactors = FALSE)
names(df1) <- vars
df1
#' examine the values, note this combines the values for both sexes
summary(df1$g)
hist(df1$g)
#' run the model for 5 x 1000 ticks and extract the reporters (the genotype)
#' every 1000 ticks
test <- NLDoReport(5, "repeat 1000 [go]", c("ticks",reporters), as.data.frame=T, df.col.names=c("ticks",reporters))
print(test)
class(test)
test$`map [x -> [g] of x ] sort turtles`
mydata <- data.frame(cbind(unlist(test$`map [x -> [sex] of x ] sort turtles`)
,unlist(test$`map [x -> [g] of x ] sort turtles`), unlist(test$`map [x -> [ticks] of x ] sort turtles`),unlist(test$`map [x -> [anadromous] of x ] sort turtles`)
))
#' rename the variables
mydata <- rename(mydata, sex = X1, g = X2, iteration = X3, anadromous = X4)
head(mydata)
#' make sure g is classified as numeric
mydata$g <- as.numeric(as.character(mydata$g))
head(mydata)
#' plot the data
#' note the dot used in place of mydata because
#' we're using pipes
#' first for males
filter(mydata, sex == "male") %>% ggplot(.) +
geom_histogram(aes(g)) +
facet_wrap(~iteration)
#' now for females
filter(mydata, sex == "female") %>% ggplot(.) +
geom_histogram(aes(g)) +
facet_wrap(~iteration)
#' filter by resident males
filter(mydata, sex == "male", anadromous=="FALSE") %>% ggplot(.) +
geom_histogram(aes(g)) +
facet_wrap(~iteration)
#' plot individual histograms for each sampling period in base R
for (i in seq_along(g_female)) {
hist(g_female[[i]])
}
#' plot box plots for each sampling period using ggplot
p1 <- data.frame(x = unlist(g_female),
grp = rep(letters[1:length(g_female)],times = sapply(g_female,length)))
ggplot(p1,aes(x = grp, y = x)) + geom_boxplot()
#' Plot histograms for each sampling period using ggplot
#' this uses facet wrap to plot individual histograms
p2 <- data.frame(x = unlist(g_female),
grp = rep(letters[1:length(g_female)],times = sapply(g_female,length)))
ggplot(p2) +
geom_histogram(aes(x)) +
facet_wrap(~grp)
##### NetLogo Parallelization  ----
#' Simple example
testfun1 <- function(x) {
return(x*x)
}
my.v1 <- 1:10
my.v1.quad <- sapply(my.v1, testfun1)
my.v1.quad
library(parallel)
processors <- detectCores()
# create a cluster
cl <- makeCluster(processors)
# call parallel sapply
my.v1.quad.par <- parSapply(cl, my.v1, testfun1)
print(my.v1.quad.par)
stopCluster(cl)
#' NetLogo example
#' use clusters to run multiple versions of the model
#'  To parallelize RNetLogo we need this initialization to be
#'  done for every processor, because they are independent from each
#'  other (which is a very important property, because, for example,
#'  random processes in parallel simulations should not be influenced
#'  by each other).
#'
#'  Therefore, it makes sence to put the initialization, the simulation,
#'  and the quiting process into separate functions. These functions can
#'  look like the following (if you want to test these, don't forget to
#'  adapt the paths appropriate):
library(rJava)
library(RNetLogo)
#setwd("C:\\Program Files\\NetLogo 6.0.4\\app") #path where netlogo.jar file is stored - ymmv
# load the parallel package
library(parallel)
# detect the number of cores available
processors <- detectCores()
processors
# create a cluster
cl <- makeCluster(processors)
stopCluster(cl)
#' load the libraries
library(RNetLogo)
library(ggplot2)
library(tidyverse)
#' identify the location of NetLogo
NLStart("C:\\Program Files\\NetLogo 6.0.4\\app", gui = T, nl.jarname = "netlogo-6.0.4.jar")
#' path to the model on my desktop
NLLoadModel("C:\\Users\\Adam Kane\\Documents\\Manuscripts\\Trout migration\\trout-migration\\trout-migration-full-time-matrix.nlogo")
NLCommand("set anad-death-multiplierF 24")
NLCommand("set anad-death-multiplierF 2")
NLCommand("set res_quality_mean 101")
NLCommand("set res_quality_sd 9")
NLCommand("set paras_quality_mean 151")
NLCommand("set paras_quality_mean 150")
NLCommand("set paras_quality_sd 9")
NLCommand("set anad_quality_mean 101")
NLCommand("set anad_quality_sd 9")
#' setup the model again after the test
NLCommand("setup")
#' set up a reporter to collect data on the genotype of both sexes
vars <- c("ticks", "who", "g" ,"sex", "anadromous","GM")
agents <- "turtles"
reporters <- sprintf("map [x -> [%s] of x ] sort %s", vars, agents)
nlogo_ret <- RNetLogo::NLReport(reporters)
df1 <- data.frame(nlogo_ret, stringsAsFactors = FALSE)
#' setup the model again after the test
NLCommand("setup")
#' set up a reporter to collect data on the genotype of both sexes
vars <- c("ticks", "who", "g" ,"sex", "anadromous","GM")
agents <- "turtles"
reporters <- sprintf("map [x -> [%s] of x ] sort %s", vars, agents)
nlogo_ret <- RNetLogo::NLReport(reporters)
#' set up a reporter to collect data on the genotype of both sexes
vars <- c("ticks", "who", "g" ,"sex", "anadromous")
agents <- "turtles"
reporters <- sprintf("map [x -> [%s] of x ] sort %s", vars, agents)
nlogo_ret <- RNetLogo::NLReport(reporters)
df1 <- data.frame(nlogo_ret, stringsAsFactors = FALSE)
names(df1) <- vars
df1
#' examine the values, note this combines the values for both sexes
summary(df1$g)
hist(df1$g)
NLQuit()
#' load the libraries
library(RNetLogo)
library(ggplot2)
library(tidyverse)
#' identify the location of NetLogo
#' this returns an error code but it still works
NLStart("C:\\Program Files\\NetLogo 6.0.4\\app", gui = T, nl.jarname = "netlogo-6.0.4.jar")
#' path to the model on my desktop
NLLoadModel("C:\\Users\\Adam Kane\\Documents\\Manuscripts\\Trout migration\\trout-migration\\trout-migration-full-time-matrix.nlogo")
#' path to the model on my laptop
NLLoadModel("C:\\Users\\Adam\\Documents\\Science\\Manuscripts\\trout-migration\\trout-migration-full-time-matrix.nlogo")
#' change the parameter values
#'
#' starting population of trout
NLCommand("set n-trout 100")
#' male freshwater mortality
NLCommand("set mortalityM 1e-05")
#' female freshwater mortality
NLCommand("set mortalityF 1e-05")
#' male marine mortality multiplier
NLCommand("set anad-death-multiplierM 2")
#' female marine mortality multiplier
NLCommand("set anad-death-multiplierF 2")
#' cost of being parasitised multiplier
NLCommand("set parasite-load 3")
#' range that females can see potential mates
NLCommand("set female-mate-radius 3")
#' freshwater carrying capacity
NLCommand("set carrying-capacity 200")
#' change the parameter values
#'
#' starting population of trout
NLCommand("set n-trout 90")
#' setup the model again after the test
NLCommand("setup")
#' set up a reporter to collect data on the genotype of both sexes
vars <- c("ticks", "who", "g" ,"sex", "anadromous", "gm_val")
agents <- "turtles"
reporters <- sprintf("map [x -> [%s] of x ] sort %s", vars, agents)
nlogo_ret <- RNetLogo::NLReport(reporters)
#' run the model for x by y ticks and extract the reporters
#' every y ticks
test <- NLDoReport(5, "repeat 1000 [go]", c("ticks",reporters), as.data.frame=T, df.col.names=c("ticks",reporters))
print(test)
class(test)
test$`map [x -> [g] of x ] sort turtles`
mydata <- data.frame(cbind(unlist(test$`map [x -> [sex] of x ] sort turtles`),
unlist(test$`map [x -> [g] of x ] sort turtles`),
unlist(test$`map [x -> [ticks] of x ] sort turtles`),
unlist(test$`map [x -> [anadromous] of x ] sort turtles`),
unlist(test$`map [x -> [who] of x ] sort turtles`)
))
#' rename the variables
mydata <- rename(mydata, sex = X1, g = X2, iteration = X3, anadromous = X4,  who = X5)
head(mydata)
#' make sure g is classified as numeric
mydata$g <- as.numeric(as.character(mydata$g))
head(mydata)
#' first for males
filter(mydata, sex == "male") %>% ggplot(.) +
geom_histogram(aes(g)) +
facet_wrap(~iteration)
#' now for females
filter(mydata, sex == "female") %>% ggplot(.) +
geom_histogram(aes(g)) +
facet_wrap(~iteration)
#' filter by resident males
filter(mydata, sex == "male", anadromous=="FALSE") %>% ggplot(.) +
geom_histogram(aes(g)) +
facet_wrap(~iteration)
#' boxplots
mydata %>% ggplot(.) +
geom_boxplot(aes(x=iteration,y=g))
#' can extract the allele frequencies
alleleFreq <- data.frame(cbind(unlist(test$`map [x -> [gm_val] of x ] sort turtles`)))
head(alleleFreq)
#' rename
alleleFreq <- rename(alleleFreq, gm_val = cbind.unlist.test..map..x.....gm_val..of.x...sort.turtles...)
head(alleleFreq)
tail(alleleFreq,21)
length(alleleFreq$gm_val)/21
#' extract them for each fish
#' check this again to make sure it matches up!
lst <- split(alleleFreq$gm_val, (seq_along(alleleFreq$gm_val)-1) %% 21 +1); do.call(cbind, lapply(lst, "length<-", max(lengths(lst))))
#' stick them all together with the rest of the data
cbind(mydata,lst)
mydata <- cbind(mydata,lst)
mydata
#' genotype matrix
GM <- matrix(sample(0:2,size = 21,replace = T),ncol=21)
dim(GM)
GM
#' Correlation between the males and females
#'
#' negative correlation
#' create one matrix with negative elements
#' last value is 0 because this is a neutral marker
WM_neg <- matrix(c(rep(-1,20),0),ncol=21)
WM_neg
#' create one matrix with positive elements
#' last value is 0 because this is a neutral marker
WM_pos <- matrix(c(rep(1,20),0),ncol=21)
WM_pos
#' genotype matrix
GM <- matrix(sample(0:2,size = 21,replace = T),ncol=21)
GM
#' transpose of weights matrix with negatives
WM_neg_t <- t(WM_neg)
#' transpose of weights matrix with positives
WM_pos_t <- t(WM_pos)
#' multiply genotype matrix by transpose of weights matrix
#' this produces the genetic value
#' here for the negative matrix
GM %*% WM_neg_t
#' here for the positive matrix
GM %*% WM_pos_t
#' Look at the case with some values negative and some positive
#' this will give us an r in between the extremes of - 1 and + 1
WM_inter <- matrix(c(rep(-1,10),rep(1,10),0),ncol=21)
WM_inter
#' genotype matrix
GM <- matrix(sample(0:2,size = 21,replace = T),ncol=21)
GM
#' transpose of weights matrix with negatives
WM_inter_t <- t(WM_inter)
#' multiply genotype matrix by transpose of weights matrix
#' this produces the genetic value
#' here for the negative matrix
GM %*% WM_inter_t
WM_inter <- matrix(c(rep(-1,10),rep(1,10),0),ncol=21)
WM_inter
#' genotype matrix
GM <- matrix(sample(0:2,size = 21,replace = T),ncol=21)
dim(GM)
#' transpose of weights matrix with negatives
WM_inter_t <- t(WM_inter)
#' multiply genotype matrix by transpose of weights matrix
#' this produces the genetic value
#' here for the negative matrix
GM %*% WM_inter_t
WM_inter <- matrix(c(rep(-1,10),rep(1,10),0),ncol=21)
WM_inter
#' genotype matrix
GM <- matrix(sample(0:2,size = 21,replace = T),ncol=21)
dim(GM)
#' transpose of weights matrix with negatives
WM_inter_t <- t(WM_inter)
#' multiply genotype matrix by transpose of weights matrix
#' this produces the genetic value
#' here for the negative matrix
GM %*% WM_inter_t
WM_inter <- matrix(c(rep(-1,10),rep(1,10),0),ncol=21)
WM_inter
#' genotype matrix
GM <- matrix(sample(0:2,size = 21,replace = T),ncol=21)
dim(GM)
#' transpose of weights matrix with negatives
WM_inter_t <- t(WM_inter)
#' multiply genotype matrix by transpose of weights matrix
#' this produces the genetic value
#' here for the negative matrix
GM %*% WM_inter_t
WM_inter <- matrix(c(rep(-1,10),rep(1,10),0),ncol=21)
WM_inter
#' genotype matrix
GM <- matrix(sample(0:2,size = 21,replace = T),ncol=21)
dim(GM)
#' transpose of weights matrix with negatives
WM_inter_t <- t(WM_inter)
#' multiply genotype matrix by transpose of weights matrix
#' this produces the genetic value
#' here for the negative matrix
GM %*% WM_inter_t
WM_inter <- matrix(c(rep(-1,10),rep(1,10),0),ncol=21)
WM_inter
#' genotype matrix
GM <- matrix(sample(0:2,size = 21,replace = T),ncol=21)
dim(GM)
#' transpose of weights matrix with negatives
WM_inter_t <- t(WM_inter)
#' multiply genotype matrix by transpose of weights matrix
#' this produces the genetic value
#' here for the negative matrix
GM %*% WM_inter_t
WM_inter <- matrix(c(rep(-1,10),rep(1,10),0),ncol=21)
WM_inter
#' genotype matrix
GM <- matrix(sample(0:2,size = 21,replace = T),ncol=21)
dim(GM)
#' transpose of weights matrix with negatives
WM_inter_t <- t(WM_inter)
#' multiply genotype matrix by transpose of weights matrix
#' this produces the genetic value
#' here for the negative matrix
GM %*% WM_inter_t
mydata
mydata
#' setup the model again after the test
NLCommand("setup")
#' set up a reporter to collect data on the genotype of both sexes
vars <- c("ticks", "who", "g" ,"sex", "anadromous", "gm_val")
agents <- "turtles"
reporters <- sprintf("map [x -> [%s] of x ] sort %s", vars, agents)
nlogo_ret <- RNetLogo::NLReport(reporters)
#' run the model for x by y ticks and extract the reporters
#' every y ticks
test <- NLDoReport(10, "repeat 1000 [go]", c("ticks",reporters), as.data.frame=T, df.col.names=c("ticks",reporters))
print(test)
class(test)
test$`map [x -> [g] of x ] sort turtles`
mydata <- data.frame(cbind(unlist(test$`map [x -> [sex] of x ] sort turtles`),
unlist(test$`map [x -> [g] of x ] sort turtles`),
unlist(test$`map [x -> [ticks] of x ] sort turtles`),
unlist(test$`map [x -> [anadromous] of x ] sort turtles`),
unlist(test$`map [x -> [who] of x ] sort turtles`)
))
#' rename the variables
mydata <- rename(mydata, sex = X1, g = X2, iteration = X3, anadromous = X4,  who = X5)
head(mydata)
#' make sure g is classified as numeric
mydata$g <- as.numeric(as.character(mydata$g))
head(mydata)
class(mydata$iteration)
#' make sure iteration is classified as numeric
mydata$iteration <- as.character(mydata$iteration)
head(mydata)
levels(mydata$iteration)
#' make sure iteration is classified as numeric
mydata$iteration <- as.factor(mydata$iteration)
head(mydata)
mydata
#' rename the variables
mydata <- rename(mydata, sex = X1, g = X2, iteration = X3, anadromous = X4,  who = X5)
head(mydata)
#' make sure g is classified as numeric
mydata$g <- as.numeric(as.character(mydata$g))
head(mydata)
mydata <- data.frame(cbind(unlist(test$`map [x -> [sex] of x ] sort turtles`),
unlist(test$`map [x -> [g] of x ] sort turtles`),
unlist(test$`map [x -> [ticks] of x ] sort turtles`),
unlist(test$`map [x -> [anadromous] of x ] sort turtles`),
unlist(test$`map [x -> [who] of x ] sort turtles`)
))
#' rename the variables
mydata <- rename(mydata, sex = X1, g = X2, iteration = X3, anadromous = X4,  who = X5)
head(mydata)
#' make sure g is classified as numeric
mydata$g <- as.numeric(as.character(mydata$g))
head(mydata)
#' plot the data
#' note the dot used in place of mydata because
#' we're using pipes
#'
mydata$iteration_mod <- factor(mydata$iteration_mod, levels = sort(levels(mydata$iteration_mod)))
#' plot the data
#' note the dot used in place of mydata because
#' we're using pipes
#'
mydata$iteration_mod <- factor(mydata$iteration, levels = sort(levels(mydata$iteration)))
#' first for males
filter(mydata, sex == "male") %>% ggplot(.) +
geom_histogram(aes(g)) +
facet_wrap(~iteration_mod)
mydata$iteration_mod
ggplot(mydata,aes(iteration, g)) +
stat_summary(geom = "line", fun.y = mean) +
stat_summary(geom = "ribbon", fun.data = mean_cl_normal, alpha = 0.3)
head(mydata)
ggplot(mydata,aes(as.numeric(iteration), g)) +
stat_summary(geom = "line", fun.y = mean) +
stat_summary(geom = "ribbon", fun.data = mean_cl_normal, alpha = 0.3)
ggplot(mydata,aes(as.numeric(iteration), g,col=sex)) +
stat_summary(geom = "line", fun.y = mean) +
stat_summary(geom = "ribbon", fun.data = mean_cl_normal, alpha = 0.3)
as.numeric(iteration)
mydata$iteration
?sort
ggplot(mydata,aes(sort(iteration), g,col=sex)) +
stat_summary(geom = "line", fun.y = mean) +
stat_summary(geom = "ribbon", fun.data = mean_cl_normal, alpha = 0.3)
as.numeric
ggplot(mydata,aes(as.numeric(iteration), g,col=sex)) +
stat_summary(geom = "line", fun.y = mean) +
stat_summary(geom = "ribbon", fun.data = mean_cl_normal, alpha = 0.3)
ggplot(mydata,aes(as.numeric(sort(iteration)), g,col=sex)) +  stat_summary(geom = "line", fun.y = mean) +
stat_summary(geom = "ribbon", fun.data = mean_cl_normal, alpha = 0.3)
as.numeric(sort(iteration))
as.numeric(sort(mydata$iteration))
ggplot(mydata,aes(as.numeric(as.character(sort(iteration))), g,col=sex)) +  stat_summary(geom = "line", fun.y = mean) +
stat_summary(geom = "ribbon", fun.data = mean_cl_normal, alpha = 0.3)
as.numeric(as.character(sort(mydata$iteration)))
mydata <- data.frame(cbind(unlist(test$`map [x -> [sex] of x ] sort turtles`),
unlist(test$`map [x -> [g] of x ] sort turtles`),
unlist(test$`map [x -> [ticks] of x ] sort turtles`),
unlist(test$`map [x -> [anadromous] of x ] sort turtles`),
unlist(test$`map [x -> [who] of x ] sort turtles`)
))
#' rename the variables
mydata <- rename(mydata, sex = X1, g = X2, iteration = X3, anadromous = X4,  who = X5)
head(mydata)
#' make sure g is classified as numeric
mydata$g <- as.numeric(as.character(mydata$g))
head(mydata)
?sort
mydata$iteration <- factor(mydata$iteration,levels=c(mydata$iteration))
NLQuit()
